---
title: "Getting started with OpenTelemetry Metrics in .NET. Part 2: Instrumenting an application"
date: 2022-09-27T10:07:53+02:00
tags: ["opentelemetry", "dotnet", "csharp", "metrics", "prometheus", "grafana"]
description: "In this 2 part series-post I’m going to show you how to use OpenTelemetry to generate custom metrics and how to visualize those metrics using Prometheus and Grafana. In part 2 I’ll be showing you how to add OpenTelemetry Metrics on a real life .NET app and how to visualize those metrics using Prometheus and Grafana."
draft: true
---

> This is a 2 part-series post.
> - **Part 1**: Key concepts that you should know when using OpenTelemetry Metrics with .NET.  If you want to read it, click [here](https://www.mytechramblings.com/posts/getting-started-with-opentelemetry-metrics-and-dotnet-part-1/)
> - **Part 2**: A practical example about how to add OpenTelemetry Metrics on a real life .NET app and how to visualize those metrics using Prometheus and Grafana (_Available later this week_).

**Just show me the code!**   
As always, if you don’t care about the post I have uploaded the source code on my [Github](https://github.com/karlospn/opentelemetry-metrics-demo).


The previous post was about some OpenTelemetry Metrics key concepts, now it’s time to focus on instrumenting an application.   

This is what we are going to build.

![app-otel-metrics-diagram](/img/app-otel-metrics-diagram.png)

- The **BookStore WebAPI** will generate some business metrics and use the OpenTelemetry OTLP exporter package (``OpenTelemetry.Exporter.OpenTelemetryProtocol``) to send the metric data to the **OpenTelemetry Collector**.
- The **Prometheus** server will obtain the metric data from the OpenTelemetry Collector.
- We will use a **Grafana** dashboard to visualize the OpenTelemetry metrics emitted by the BookStore WebApi.

# **Application**

The application we're going to instrument using OpenTelemetry Metrics is a book store API built using .NET6. It allows us to do the following actions:

- Get, add, update and delete book categories.
- Get, add, update and delete books.
- Get, add, update and delete inventory.
- Get, add and delete orders.
- For a better understanding, 
 
For a better understanding, here's how the database diagram looks like:

<add-img>

# **OpenTelemetry Metrics** 

The first step to do before building anything is to decide which metrics we want to generate on the application and which instruments are we going to use.

Those are the metrics we're going to generate in the BookStore app.

## BookStore custom metrics 

Those are business metrics instrumented directly on the application using the Metrics API.   

- ``BooksAddedCounter``: It counts how many books are added to the store.
- ``BooksDeletedCounter``: It counts how many books are deleted from the store.
- ``BooksUpdatedCounter``: It counts how many books are updated.
- ``TotalBooksGauge``: Total number of books that the store has at any given time.
- ``CategoriesAddedCounter``: It counts how many book categories are added to the store.
- ``CategoriesDeletedCounter``: It counts how many book categories are deleted from the store.
- ``CategoriesUpdatedCounter``: It counts how many book categories are updated.
- ``TotalCategoriesGauge``: Total number of book categories that the store has at any given time.
- ``OrdersPriceHistogram``: Shows the price distribution of the orders.
- ``NumberOfBooksPerOrderHistogram``: Shows the number of books distribution per order.
- ``OrdersCanceledCounter``: It counts how many orders has been cancelled.
- ``TotalOrdersCounter``: Total number of orders that the store has at any given time.

## Http requests metrics

Those metrics are generated by the ``OpenTelemetry.Instrumentation.AspNetCore`` NuGet package.    
This is an instrumentation library, which instruments .NET and collects metrics and traces about incoming web requests.

To start using the ``OpenTelemetry.Instrumentation.AspNetCore`` package you only need to add the ``AddAspNetCoreInstrumentation()`` extension method when setting up the .NET OpenTelemetry Tracing component. Here's an example:

```csharp
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry.Trace;

public void ConfigureServices(IServiceCollection services)
{
    services.AddOpenTelemetryTracing((builder) => builder
        .AddAspNetCoreInstrumentation()
    );
}
```

## System.Runtime performance metrics

Those metrics are generated by the ``OpenTelemetry.Instrumentation.Runtime`` NuGet package. This is an instrumentation library, which instruments .NET Runtime and collect runtime performance metrics.

To start using the ``OpenTelemetry.Instrumentation.Runtime`` package you only need to add the ``AddRuntimeInstrumentation()`` extension method when setting up the .NET OpenTelemetry Tracing component. Here's an example:

```csharp
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry.Trace;

public void ConfigureServices(IServiceCollection services)
{
    services.AddOpenTelemetryTracing((builder) => builder
        .AddRuntimeInstrumentation()
    );
}
```

The  ``OpenTelemetry.Instrumentation.Runtime`` package collects telemetry about the following ``System.Runtime`` counters:

- ``process.runtime.dotnet.gc.collections.count``: Number of garbage collections that have occurred since process start.
- ``process.runtime.dotnet.gc.allocations.size``: Count of bytes allocated on the managed GC heap since the process start
- ``process.runtime.dotnet.gc.committed_memory.size``: The amount of committed virtual memory for the managed GC heap, as observed during the latest garbage collection. 
- ``process.runtime.dotnet.gc.heap.size``: The heap size (including fragmentation), as observed during the latest garbage collection. 
- ``process.runtime.dotnet.gc.heap.fragmentation.size``: The heap fragmentation, as observed during the latest garbage collection. 
- ``process.runtime.dotnet.jit.il_compiled.size``: Count of bytes of intermediate language that have been compiled since the process start.
- ``process.runtime.dotnet.jit.methods_compiled.count``: The number of times the JIT compiler compiled a method since the process start. 
- ``process.runtime.dotnet.jit.compilation_time``: The amount of time the JIT compiler has spent compiling methods since the process start.
- ``process.runtime.dotnet.monitor.lock_contention.count``: The number of times there was contention when trying to acquire a monitor lock since the process start. 
- ``process.runtime.dotnet.thread_pool.threads.count``: The number of thread pool threads that currently exist.
- ``process.runtime.dotnet.thread_pool.completed_items.count``: The number of work items that have been processed by the thread pool since the process start.
- ``process.runtime.dotnet.thread_pool.queue.length``: The number of work items that are currently queued to be processed by the thread pool.
- ``process.runtime.dotnet.timer.count``: The number of timer instances that are currently active.
- ``process.runtime.dotnet.assemblies.count``: The number of .NET assemblies that are currently loaded.
- ``process.runtime.dotnet.exceptions.count``: Count of exceptions that have been thrown in managed code, since the observation started.

Some of the GC related metrics will be unavailable until at least one garbage collection has occurred.

# **OpenTelemetry .NET Client** 
To get started with OpenTelemetry Metrics we’re going to need the following packages.

```xml
<PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.0.0-rc9.6" />
<PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.0.0-rc9.6" />
<PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.0.0" />
<PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.3.1" />
```
- The **OpenTelemetry.Extensions.Hosting** package contains some extensions that allows us to add the dependencies into the DI container and configure the **MeterProvider**.
- The **OpenTelemetry.Instrumentation.*** packages are instrumentation libraries. These packages are instrumenting common libraries/functionalities/classes so we don’t have to do all the heavy lifting by ourselves. In our example we’re using the following ones:
    - The **OpenTelemetry.Instrumentation.AspNetCore** collects metrics and traces about incoming web requests.
    - The **OpenTelemetry.Instrumentation.Runtime** collects runtime performance metrics.
- The **OpenTelemetry.Exporter.OpenTelemetryProtocol** package allows us to export the metrics to the OpenTelemetry Collector using the OTLP protocol.

# **Add OpenTelemetry Metrics on the BookStore app**

## **1 - Setup the MeterProvider**

```csharp
var meters = new OtelMetrics();

builder.Services.AddOpenTelemetryMetrics(opts => opts
    .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService("BookStore.WebApi"))
    .AddMeter(meters.MetricName)
    .AddAspNetCoreInstrumentation()
    .AddRuntimeInstrumentation()
    .AddOtlpExporter(opts =>
    {
        opts.Endpoint = new Uri(builder.Configuration["Otlp:Endpoint"]);
    }));
```

Let's review what we’re doing line by line.

```csharp
AddOpenTelemetryMetrics()
```
OpenTelemetry Metrics works by using the ``MeterProvider`` to create a ``Meter`` and associating it with one or more ``Instruments``, each of which is used to create a series of ``Measurements``.

The ``MeterProvider ``will hold all the configuration for metrics like Meter names, readers, etc.
and must be configured to collect metrics using the ``AddOpenTelemetryMetrics()`` extension method.

```csharp
SetResourceBuilder(ResourceBuilder.CreateDefault().AddService("BookStore.WebApi"))
```
A ``Resource`` is the immutable representation of the entity producing the telemetry.
With the ``SetResourceBuilder`` method we’re configuring the ``Resource`` for the application.

The ``SetResourceBuilder`` gives us the possibility to configure attributes like the service name, application name amongst others.

```csharp
AddMeter(meters.MetricName)
```
Any ``Instrument`` that we create in our application needs to be associated with a ``Meter``. The ``AddMeter()`` extension methods configures OpenTelemetry to transmit all the metrics collected by this concrete ``Meter``.

As you'll see later in the BookStore app I have a single ``Meter`` with multiple ``Instruments`` on it, but you can also have multiple ``Meters`` per app, in this case you'll have multiple calls to the ``AddMeter()`` extension method.

```csharp
AddAspNetCoreInstrumentation()
```
This method comes from the ``OpenTelemetry.Instrumentation.AspNetCore`` NuGet package, it instruments .NET and collects metrics and traces about incoming web requests.

```csharp
AddRuntimeInstrumentation()
```
This method comes from the ``OpenTelemetry.Instrumentation.Runtime`` NuGet package, it instruments .NET and collects metrics and collects runtime performance metrics.

```csharp
AddOtlpExporter(opts =>
{
    opts.Endpoint = new Uri(builder.Configuration["Otlp:Endpoint"]);
}));
```
This method is used to configure the exporter that sends all the metric data to the OpenTelemetry Collector.

## **2 - Create the Meter and the Instruments**



## **3 - Use the Instruments to record Measurements**


# **How to run the app**

If you want to take a look at the BookStore app, you can go to my [GitHub repository](https://github.com/karlospn/opentelemetry-metrics-demo).

If you want to try for yourselves to execute this example, I have uploaded also a docker-compose file with everything you need, so you can run a compose up and you’re good to go.




