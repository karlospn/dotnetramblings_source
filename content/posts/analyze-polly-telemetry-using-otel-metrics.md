---
title: "Analyze Polly Telemetry using OpenTelemetry Metrics"
date: 2023-10-25T12:25:31+02:00
description: "Starting with version 8, Polly provides Telemetry for all built-in strategies. This post will show you how you can send this Telemetry to Prometheus and Grafana for a more in-depth analysis using OpenTelemetry Metrics."
tags: ["dotnet", "opentelemetry", "metrics"]
draft: true
---

> **Just show me the code!**   
> As always, if you donâ€™t care about the post I have uploaded the source code on my [Github](https://github.com/karlospn/analyze-polly-telemetry-using-otel-metrics).


This post does not aim to be an introductory post on how the Polly library works, how to configure its various strategies, etc. There are already multiple posts on the Internet that explain these topics very well.

I'm not going to delve into specific details about how OpenTelemetry Metrics work, such as what a Meter is or how the OTEL Collector operates.     
If you want to learn more about OpenTelemetry Metrics and how to use it with .NET, you can read my introductory post that I wrote a few months ago. 
> Here's a link to my _["Getting started with OpenTelemetry Metrics in .NET"](https://www.mytechramblings.com/posts/getting-started-with-opentelemetry-metrics-and-dotnet-part-1/)_ blog psot.

The goal of this post is to show you **how we can use OpenTelemetry Metrics to send the Telemetry generated by Polly to Prometheus for subsequent analysis by setting up a series of dashboards in Grafana**.

It's important to mention that Polly provides Telemetry for all built-in resilience strategies starting with version 8. It's crucial to emphasize that **this post does not work with versions of Polly earlier than version 8**.

So, without further ado, let's get started.

# **What is Polly?**

Polly is a .NET library that aids in building resilient and fault-tolerant applications. 

It is primarily used for improving the stability and resilience of a .NET application by handling transient faults, system failures, and network outages. The library helps developers implement various resilience patterns, such as retries, circuit breakers, and timeouts, to improve the reliability of your applications.

- Would you like to learn more about it? Visit its official [Github repository](https://github.com/App-vNext/Polly)


# **Enable Telemetry on Polly**


By default, Polly Telemetry is disabled. To enable it you need to install the ``Polly.Extensions`` NuGet package and use the ``ConfigureTelemetry`` extension method when building any resilience strategy.

- The next code snippet shows a basic example where we enable Telemetry when building a Timeout Polly strategy.

```csharp
var builder = new ResiliencePipelineBuilder()
    .AddTimeout(TimeSpan.FromSeconds(1))
    .ConfigureTelemetry(new NullLoggerFactory())
    .Build();
```

The ``ConfigureTelemetry`` extension method can be setup in a couple different ways:

- To accept an ``ILoggerFactory`` instance, which will allow us to log every Telemetry events.
```csharp
public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, ILoggerFactory loggerFactory)
        where TBuilder : ResiliencePipelineBuilderBase
    {
        Guard.NotNull(builder);
        Guard.NotNull(loggerFactory);

        return builder.ConfigureTelemetry(new TelemetryOptions { LoggerFactory = loggerFactory });
    }
```

- To accept a ``TelemetryOptions`` instance:

```csharp
public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, TelemetryOptions options)
    where TBuilder : ResiliencePipelineBuilderBase
{
    Guard.NotNull(builder);
    Guard.NotNull(options);

    ValidationHelper.ValidateObject(new(options, $"The '{nameof(TelemetryOptions)}' are invalid."));
    builder.TelemetryListener = new TelemetryListenerImpl(options);

    return builder;
}
```

The ``TelemetryOptions`` object allow us to do more than just logging Polly Telemetry events; it also enables us to configure Telemetry listeners or add custom tags to any event created by any Polly Strategy.

- Here's how the ``TelemetryOptions`` object looks like:

```csharp
public class TelemetryOptions
{
    /// <summary>
    /// Gets the collection of telemetry listeners.
    /// </summary>
    /// <value>
    /// The default value is an empty collection.
    /// </value>
    public ICollection<TelemetryListener> TelemetryListeners { get; } = new List<TelemetryListener>();

    /// <summary>
    /// Gets or sets the logger factory.
    /// </summary>
    /// <value>
    /// The default value is <see cref="NullLoggerFactory.Instance"/>.
    /// </value>
    [Required]
    public ILoggerFactory LoggerFactory { get; set; } = NullLoggerFactory.Instance;

    /// <summary>
    /// Gets the collection of telemetry enrichers.
    /// </summary>
    /// <value>
    /// The default value is an empty collection.
    /// </value>
    public ICollection<MeteringEnricher> MeteringEnrichers { get; } = new List<MeteringEnricher>();

    /// <summary>
    /// Gets or sets the result formatter.
    /// </summary>
    /// <value>
    /// The default value is a formatter that returns a status code for HTTP based responses and the result as-is for all other result types.
    /// This property is required.
    /// </value>
    [Required]
    public Func<ResilienceContext, object?, object?> ResultFormatter { get; set; } = (_, result) => result switch
    {
        HttpResponseMessage response => (int)response.StatusCode,
        _ => result,
    };
}
```

# **Polly Metrics and Instruments**

In this section, I would explore the Instruments and Metrics that Polly has built-in.

The Polly built-in Telemetry implementation can be found in the _[Polly.Telemetry.TelemetryListenerImpl](https://github.com/App-vNext/Polly/blob/main/src/Polly.Extensions/Telemetry/TelemetryListenerImpl.cs)_ class.   

Within this class, we find the creation of the ``Meter`` and the ``Instruments`` responsible for reporting ``Measuments``. These are fundamental concepts in OpenTelemetry Metrics. Let's do a quick recap of what each of these terms means:

- A ``Meter`` is responsible for creating ``Instruments`` and it must provide a series of functions to create new ``Instruments``.
- A ``Meter`` can be associated with one or more ``Instruments``, each of which is used to create a series of ``Measurements``.
- ``Measurements`` are what we create or observe in our applications.


All the metrics emitted by Polly can be found inside the "Polly" ``Meter``.

```csharp
 internal static readonly Meter Meter = new(TelemetryUtil.PollyDiagnosticSource, "1.0");
```

 The ``TelemetryUtil.PollyDiagnosticSource`` is nothing more than a string:   
``internal const string PollyDiagnosticSource = "Polly";``

Right now, Polly has these 3 built-in ``Instruments`` capable of emitting ``Measurements``:

```csharp
Counter = Meter.CreateCounter<int>(
        "resilience.polly.strategy.events",
        description: "Tracks the number of resilience events that occurred in resilience strategies.");

AttemptDuration = Meter.CreateHistogram<double>(
    "resilience.polly.strategy.attempt.duration",
    unit: "ms",
    description: "Tracks the duration of execution attempts.");

ExecutionDuration = Meter.CreateHistogram<double>(
    "resilience.polly.pipeline.duration",
    unit: "ms",
    description: "The execution duration of resilience pipelines.");
```

These are the ``Instruments`` that will generate the metrics that we will send to Prometheus and Grafana for further analysis.


# **Demo Application**

In the previous section, we have seen how to enable the built-in Telemetry in Polly and also which metrics will be emitted by it. Now it's time to build an app that generates some of those metrics.

The following diagram shows what we're going to build from this point forward.

![polly-metrics-components-diagram](/img/polly-metrics-components-diagram.png)

- A .NET WebAPI that makes calls to the https://jsonplaceholder.typicode.com/ API, utilizing various Polly strategies to enhance resiliency during these HTTP requests.
- The WebApi uses the OpenTelemetry Metrics alongside the OTLP exporter package (``OpenTelemetry.Exporter.OpenTelemetryProtocol``) to send the Polly Telemetry to an OpenTelemetry Collector.
- A Prometheus server that retrieves the Polly metric data from the OTEL Collector.
- A Grafana server preconfigured with a dashboard for visualizing the Polly metrics sent by the WebAPI.


# **Building the .NET WebApi**

The application is a simple .NET 7 WebApi that makes calls to the ``jsonplaceholder.typicode.com`` API and returns the result.

The application features 2 endpoints: ``/Comments`` and ``/Users``.


## **1. Building the /comments endpoint**

This endpoint makes a call to the ``https://jsonplaceholder.typicode.com/posts/{commentId}/comments`` endpoint and returns the result.

To invoke the TypiCode API, the app will use an HttpClient with a Polly Retry/Timeout strategy attached to it.

The first step is to create the Polly Strategy, which will exhibit the following behavior:
- It will handle any exceptions or 500 status codes returned by the TypiCode API.
- In the event of an HTTP call failure, it will retry the call up to 5 times with a 5-second delay between each retry.
- If the HTTP call doesn't receive a response within 5 seconds, it will be canceled.

The next code snippet shows the Polly Strategy implementation. Notice how, when building the Polly Strategy, we are using the ``ConfigureTelemetry()`` extension method. This is because we want metrics to be generated every time this Strategy is executed.    
If we don't use the ``ConfigureTelemetry()`` extension method when creating the Pipeline, then there won't any metric for us to work with.   
Additionally, we are outputting the Telemetry data to the Console using the ``LoggerFactory.Create(bld => bld.AddConsole()`` delegate method.

```csharp
public static ResiliencePipeline<HttpResponseMessage> CreateRetryStrategy()
{
    var retry = new ResiliencePipelineBuilder<HttpResponseMessage>
    {
        Name = "TypiCodeCommentsRetryPipeline"
    };

    var pipeline = retry.AddRetry(new RetryStrategyOptions<HttpResponseMessage>
    {
        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()
            .Handle<Exception>()
            .HandleResult(r => r.StatusCode == HttpStatusCode.InternalServerError),
        Name = "RetryStrategy",
        MaxRetryAttempts = 5,
        Delay = TimeSpan.FromSeconds(5),
        OnRetry = arg =>
        {
            Console.WriteLine("OnRetry, Attempt: {0}", arg.AttemptNumber);
            return default;
        }
    })
    .AddTimeout(TimeSpan.FromSeconds(5))
    .ConfigureTelemetry(LoggerFactory.Create(bld => bld.AddConsole()))
    .Build();

    return pipeline;
}
```

Now, let's create the HttpClient and attach the Polly Strategy.    

To create the HttpClient, I will use the ``AddHttpClient`` extension method from the ``Microsoft.Extensions.DependencyInjection`` package. This method adds the ``IHttpClientFactory`` and related services to the DI container and configures a named HttpClient.

To attach the Polly Strategy we have created earlier, we will use the ``AddPolicyHandler()`` extension method. This  method adds a ``PolicyHttpMessageHandler`` which will surround request execution with the provided policy.   

There is a caveat here: you need to use the ``AsAsyncPolicy()`` method from the ``Polly`` package. This method converts a ``ResiliencePipeline`` into an ``IAsyncPolicy``. It's necessary because the ``AddPolicyHandler()`` method anticipates only accepts an ``IAsyncPolicy`` parameter. 

The next code snippet shows the implementation.

```csharp
builder.Services.AddHttpClient("typicode-comments", c =>
{
    c.BaseAddress = new Uri(builder.Configuration.GetValue<string>("TypiCodeBaseUri") ??
                            throw new InvalidOperationException());
    c.DefaultRequestHeaders.Add("accept", "application/json");

}).AddPolicyHandler(PollyResiliencePipelines.CreateRetryStrategy().AsAsyncPolicy());
```

## **2. Building the /users endpoint**

This endpoint makes a call to the ``https://jsonplaceholder.typicode.com/users/{userId}`` endpoint and returns the result.

To invoke the TypiCode API, the app will use an HttpClient with a Polly Circuit Breaker Strategy attached to it.

The first step is to create the Polly Strategy, which will exhibit the following behavior:
- It will handle exceptions of type HttpRequestException or 500 status codes returned by the TypiCode API.
- If there are more than 5 HTTP calls within 30 seconds, and 30% of them result in a failure, the circuit will open for 15 seconds.

The following code snippet shows the implementation of the Polly Circuit Breaker Strategy. Notice how, when building the Polly Strategy, we are using the ``ConfigureTelemetry()`` extension method. This is because we want metrics to be generated every time this Strategy is executed.    

Additionally, we are adding a custom tag to our metrics. To achieve this, you need to create a class that inherits from the ``MeteringEnricher`` class and then add your custom enricher to the ``TelemetryOptions.MeteringEnrichers`` list.


```csharp
public static ResiliencePipeline<HttpResponseMessage> CreateCircuitBreakerStrategy()
{

    var circuitBreaker = new ResiliencePipelineBuilder<HttpResponseMessage>
    {
        Name = "TypiCodeUsersCircuitBreakerPipeline"
    };

    var pipeline = circuitBreaker.AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage> 
    {
        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()
            .Handle<HttpRequestException>()
            .HandleResult(r => r.StatusCode == HttpStatusCode.InternalServerError),
        Name = "CircuitBreakerStrategy",
        BreakDuration = TimeSpan.FromSeconds(15),
        FailureRatio = .3,
        MinimumThroughput = 5,
        SamplingDuration = TimeSpan.FromSeconds(30),
        OnOpened = arg =>
        {
            Console.WriteLine("Circuit Breaker Opened, Duration: {0}", arg.BreakDuration);
            return default;
        },
        OnClosed = _ =>
        {
            Console.WriteLine("Circuit Breaker Closed");
            return default;
        },
        OnHalfOpened = _ =>
        {
            Console.Write("Circuit Breaker Half Opened");
            return default;
        }
    })
    .ConfigureTelemetry(new TelemetryOptions
    {
        MeteringEnrichers = { new CircuitBreakerMetersEnricher() }
    })
    .Build();

    return pipeline;
}
```

The following code snippet illustrates the implementation of this custom enricher. This enricher adds the duration of the open circuit into the ``OnCircuitOpened`` events.

```csharp
internal class CircuitBreakerMetersEnricher : MeteringEnricher
{
    public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context)
    {
        if (context.TelemetryEvent.Arguments is OnCircuitOpenedArguments<TResult> onCircuitOpenedArgs)
        {
            context.Tags.Add(new("circuitbreaker.open.duration", onCircuitOpenedArgs.BreakDuration));
        }
    }
}
```

Now, let's create the HttpClient and attach the Polly Circuit Breaker Strategy. The source code is exactly the same as the one mentioned above, so there's no need to repeat it.

```csharp
builder.Services.AddHttpClient("typicode-comments", c =>
{
    c.BaseAddress = new Uri(builder.Configuration.GetValue<string>("TypiCodeBaseUri") ??
                            throw new InvalidOperationException());
    c.DefaultRequestHeaders.Add("accept", "application/json");

}).AddPolicyHandler(PollyResiliencePipelines.CreateRetryStrategy().AsAsyncPolicy());
```

## **3. Configure OpenTelemetry Metrics .NET provider**


# **OpenTelemetry Collector**

# **Prometheus**

# **Grafana**

# **How to test the application**