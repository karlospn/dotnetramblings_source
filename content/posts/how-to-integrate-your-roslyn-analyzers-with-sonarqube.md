---
title: "How to integrate your Roslyn Analyzers with Sonarqube"
date: 2023-02-20T13:30:55+01:00
tags: ["dotnet", "roslyn", "devops", "sonarqube"]
description: "TBD"
draft: true
---

> **Show me the code**   
> As always, if you don't care about the post I have uploaded the source code on my [Github](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube)

If you work regularly with .NET you probably heard about Roslyn Analyzers, and if you don't know anything about them it's quite possible that you have being used them without knowing it.

The .NET SDK includes quite a few Roslyn Analyzers starting with Visual Studio 2019 and .NET 5.0, which means that when you create a new .NET app in Visual Studio, you'll see that it comes with a few a Roslyn Analyzers packages already preconfigured from the get-go.

<add-img>

Currently you don't see much talk about Roslyn Analyzers, but they are still the de facto way when you want to perform any kind of static analysis in your codebase.   
If you own any kind of NuGet package, having a set of Roslyn analyzers to help enforce the correct usage and setup of your library might be a really nice offering.

On the other hand, SonarQube is one of the most well-known tools for performing static code analysis, it comes prepacked with a huge array of [csharp rules](https://rules.sonarsource.com/csharp) to try to enforce best practices, but what can we do if we want to add our custom Roslyn rules into SonarQube?    

What are the available options if we want to integrate Roslyn analyzers with SonarQube so that issues detected by the Roslyn analyzers are reported and managed in SonarQube?

There are 2 ways to add Roslyn analyzers rules to SonarQube:

- Create a Java plugin from the Roslyn Analyzer and install it into SonarQube.
- Import the issues report generated by the Roslyn Analyzer into SonarQube.

**In this post I want to show you how you can integrate a Roslyn Analyzer with SonarQube using both ways: plugin and issues report.**   
**Also I'll enumerate the pros and cons of using each one of the available options.**


# **Create a rules plugin from your Roslyn Analyzer and install it into SonarQube**

One way to integrate a Roslyn Analyzer with SonarQube is to create a plugin from it and then install the plugin into SonarQube.

To generate a SonarQube plugin from a Roslyn Analyzer you need to do the following steps:
- Package your Roslyn Analyzer into a NuGet package.
- Use the ``RoslynSonarQubePluginGenerator`` tool to convert the NuGet package into a SonarQube plugin. 
    - The generator tool can be found [here](https://github.com/SonarSource/sonarqube-roslyn-sdk).

Then the SonarQube plugin must be installed into your SonarQube instance (you just need to put it in the SonarQube server ``/extensions/plugins`` folder and restart the server).   
After installing the plugin will see a new repository containing all of the rules defined on your Roslyn Analyzer. The rules can be added to Quality Profiles just like any other SonarQube rule.

Let me show you an end-to-end example.

## **Example**

### **Step 1: Create the SonarQube plugin**

I have built and packed a Roslyn Analyzer library in advance. The library contains a simple (and stupid) rule that reports a diagnostic if a class name contains a lowercase letters.
- You can find the Roslyn Analyzer library source code on my [Github repository](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube/tree/main/MyRoslynAnalyzer).
- You can get the NuGet package from [nuget.org](https://www.nuget.org/packages/MyRoslynAnalyzer).

The first step is to convert the NuGet package that contains the roslyn rules into a SonarQube plugin, to do that you need to download the ``RoslynSonarQubePluginGenerator`` tool from [here](https://github.com/SonarSource/sonarqube-roslyn-sdk) and run the following command:

``./RoslynSonarQubePluginGenerator.exe /a:MyRoslynAnalyzer /acceptLicenses``

The tool will create a .jar file named after the package name and version in the current directory e.g. myroslynanalyzer-plugin-1.0.0.jar


### **Step 2: Install the plugin in your SonarQube instance**

To install the plugin:
- If you're running SonarQube on a virtual machine, you need to put the .jar file in the ``/extensions/plugins`` folder and restart the server.
- If you're running SonarQube on a container, the easiest way is to create a new sonarqube image that contains the plugin, something like this: 

```yaml
FROM sonarqube:9.9.0-community
COPY * /opt/sonarqube/extensions/plugins/
```


## **Pros and cons**

**Pros**
- You can configure the rules in SonarQube ( e.g. Ability to select which rules of your roslyn analyzer apply to a certain quality gate, set the error level, etc.)
- You don't have to install the roslyn analyzer rules library on any application. Every project will be forced to pass the roslyn rules as long as it is associated with a quality gate that has the rule enabled.

**Cons**
- Do not work with SonarCloud, it only works with SonarQube. 
- Depends on an external tool to generate a compatible SonarQube plugin.
- To install or update the plugin you must tinker with the SonarQube server filesystem.
- The SonarQube analysis result might be inconsistent if a roslyn rule doesn't specify a location _(more information in the "Issue when integration a roslyn rule with no location with SonarQube" section)_.

# **Import the issues report generated by your Roslyn Analyzer into SonarQube.**

Another way to integrate a Roslyn Analyzer with SonarQube is to import the issues report generated by you Roslyn Analyzer into SonarQube.   

This is a really simply process with only 2 steps:
- Package your Roslyn Analyzer into a NuGet package
- Install this package in your .NET applications.

Issues generated from your Roslyn Analyzer are included in the MSBuild output and imported by default into SonarQube.

This integration is easier than the other one, but lacks some features (such as being able to control their execution by inclusion in a quality profile).

## **Example**

## **Pros and cons**

**Pros**
- Very easy to implement.
- Works with both SonarQube and SonarCloud.

**Cons**
- Unable to configure the rules in SonarQube. The issues are always reported as external issues.
- You have to install the roslyn analyzer rules library as a NuGet package on the target application. This model of integrating with SonarQube relies in the fact that the application developer must install the rules package on the application.
- Unable to report issues when a roslyn rule doesn't specify a location _(more information in the "Issue when integration a roslyn rule with no location with SonarQube" section)_.

# **Issue when integration a roslyn rule with no location with SonarQube**

> _If someone knows a way to fix this issue, DM me on Github or Linkedin._

Take a look at this rule:

```csharp
public class ClassContainsLowerCaseCharactersAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "MTR-001";

    private static readonly LocalizableString Title = new LocalizableResourceString(nameof(Resources.AnalyzerTitle), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormat), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString Description = new LocalizableResourceString(nameof(Resources.AnalyzerDescription), Resources.ResourceManager, typeof(Resources));
    private const string Category = "Naming";
    private const string HelpLink = "https://www.mytechramblings.com";

    private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, 
        Title, 
        MessageFormat, 
        Category, 
        DiagnosticSeverity.Warning, 
        isEnabledByDefault: true, 
        description: Description,
        helpLinkUri: HelpLink);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
    }

    private static void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

        if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
        {
            var diagnostic = Diagnostic.Create(Rule, Location.None);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
```

It is a (stupid) rule that reports a diagnostic for every class name that contains a lowercase. If we test this rule on a newly created .NET 7 api, here's the build output:

<add-img>

As you can see the csharp compiler raises 3 warnings but those warnings had no concrete location, this is because the rule doesn't specify the location when reporting a diagnostic:

```csharp
var diagnostic = Diagnostic.Create(Rule, Location.None);
context.ReportDiagnostic(diagnostic);
```

If we integrate this rule using the plugin approach, this is what we will see on SonarQube:

<add-img>

As you can see, there is only 1 issue present when the csharp compile report 3 warnings.

It is even worse when we integrate this rule with SonarQube using the issues report generated by the ``sonarscanner`` tool, becase no issue appears on SonarQube.

<add-img>

In conclusion, if you have a rule that doesn't report a location, it might not show up in SonarQube.
