---
title: "How to integrate your Roslyn Analyzers with Sonarqube"
date: 2023-02-20T13:30:55+01:00
tags: ["dotnet", "roslyn", "devops", "sonarqube"]
description: "TBD"
draft: true
---

> **Show me the code**   
> As always, if you don't care about the post I have uploaded the source code on my [Github](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube)

If you work regularly with .NET you probably heard about Roslyn Analyzers, and if you don't know anything about them it's quite possible that you have being used them without knowing it.

The .NET SDK includes quite a few Roslyn Analyzers starting with Visual Studio 2019 and .NET 5.0, which means that when you create a new .NET app in Visual Studio, you'll see that it comes with a few a Roslyn Analyzers packages already preconfigured from the get-go.

![sonarqube-net7-api-analyzers](/img/sonarqube-net7-api-analyzers.png)

Currently you don't see much talk about Roslyn Analyzers, but they are still the de facto way when you want to perform any kind of static analysis in your codebase.   
If you own any kind of NuGet package, having a set of Roslyn analyzers to help enforce the correct usage and setup of your library might be a really nice offering.

On the other hand, SonarQube is one of the most well-known tools for performing static code analysis, it comes prepacked with a huge array of [csharp rules](https://rules.sonarsource.com/csharp) to try to enforce best practices, but what can we do if we want to add our custom Roslyn rules into SonarQube?    

What are the available options if we want to integrate Roslyn analyzers with SonarQube so that issues detected by the Roslyn analyzers are reported and managed in SonarQube?

There are 2 ways to add Roslyn analyzers rules to SonarQube:

- Create a Java plugin from the Roslyn Analyzer and install it into SonarQube.
- Import the issues report generated by the Roslyn Analyzer into SonarQube.

**In this post I want to show you how you can integrate a Roslyn Analyzer with SonarQube using both ways: plugin and issues report.**   
**Also I'll enumerate the pros and cons of using each one of the available options.**


# **Create a rules plugin from your Roslyn Analyzer and install it into SonarQube**

One way to integrate a Roslyn Analyzer with SonarQube is to create a plugin from it and then install the plugin into SonarQube.

To generate a SonarQube plugin from a Roslyn Analyzer you need to do the following steps:
- Package your Roslyn Analyzer into a NuGet package.
- Use the ``RoslynSonarQubePluginGenerator`` tool to convert the NuGet package into a SonarQube plugin. 
    - The generator tool can be found [here](https://github.com/SonarSource/sonarqube-roslyn-sdk).

Then the SonarQube plugin must be installed into your SonarQube instance (you just need to put it in the SonarQube server ``/extensions/plugins`` folder and restart the server).   
After installing the plugin will see a new repository containing all of the rules defined on your Roslyn Analyzer. The rules can be added to Quality Profiles just like any other SonarQube rule.

Let me show you an end-to-end example.

## **Example**

### **Step 1: Create the SonarQube plugin**

I have built and packed a Roslyn Analyzer library in advance. The library contains a simple (and stupid) rule that reports a diagnostic if a class name contains a lowercase letters.
- You can find the Roslyn Analyzer library source code on my [Github repository](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube/tree/main/MyRoslynAnalyzer).
- You can get the NuGet package from [nuget.org](https://www.nuget.org/packages/MyRoslynAnalyzer).

The first step is to convert the NuGet package that contains the roslyn rules into a SonarQube plugin, to do that you need to download the ``RoslynSonarQubePluginGenerator`` tool from [here](https://github.com/SonarSource/sonarqube-roslyn-sdk) and run the following command:

``./RoslynSonarQubePluginGenerator.exe /a:MyRoslynAnalyzer /acceptLicenses``

The tool will create a .jar file named after the package name and version in the current directory e.g. myroslynanalyzer-plugin-1.0.0.jar

![sonarqube-create-roslyn-plugin](/img/sonarqube-create-roslyn-plugin.png)


### **Step 2: Install the plugin in your SonarQube instance**

To install the plugin:
- If you're running SonarQube on a virtual machine, you need to put the .jar file in the ``/extensions/plugins`` folder and restart the server.
- If you're running SonarQube on a container, the easiest way is to create a new sonarqube image that contains the plugin, something like this: 

```yaml
FROM sonarqube:9.9.0-community
COPY * /opt/sonarqube/extensions/plugins/
```

You can take a look at the plugins installed going to the "Administration" section of your SonarQube instance, the rules plugin must show up here, if it doesn't then you did something wrong.

![sonarqube-with-plugin-installed](/img/sonarqube-with-plugin-installed.png)

### **Step 3: Configure your Quality Gates to use the roslyn rules 

Now that you have installed the rules plugin on your SonarQube server, it is time to configure it as you wish.

In the "Rules" section, if you search by repository name, you'll find your custom rules.

![sonarqube-enable-roslyn-rule-on-quality-gate](/img/sonarqube-enable-roslyn-rule-on-quality-gate.png)

Now you can customize your Quality Gates whatever you see fit, and add those custom rules in whichever Quality Gate you want.

### **Step 4: Run a Sonar scan**

The last step will be to analyze a .NET application to test that the custom rules get triggered as expected.

- The app source code I will use to perform this test can be found  on my [Github repository](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube/tree/main/Demo.WebApi).
- To perform a SonarQube scan I will use the [SonarScanner CLI](https://github.com/SonarSource/sonar-scanner-cli) tool.

The next code snippet shows an example of how to perform a SonarQube scan using the SonarScanner command tool:

```bash
dotnet sonarscanner begin /k:"MyDemo.WebApi" /d:sonar.login="sqa_4278ef757202aaa56f0b632344a966be85a9383b" /d:sonar.host.url="http://localhost:9000"

dotnet build

dotnet sonarscanner end /d:sonar.login="sqa_4278ef757202aaa56f0b632344a966be85a9383b"
```

If we inspect the resulting analysis on SonarQube, we'll see that the rules from the plugin where triggered as expected.

![sonarqube-roslyn-plugin-rules-error-blocker](/img/sonarqube-roslyn-plugin-rules-error-blocker.png)


## **Pros and cons**

**Pros**
- You can configure the rules in SonarQube ( e.g. Ability to select which rules of your roslyn analyzer apply to a certain quality gate, set the error level, etc.)
- You don't have to install the roslyn analyzer rules library on any application. Every project will be forced to pass the roslyn rules as long as it is associated with a quality gate that has the rule enabled.

**Cons**
- Do not work with SonarCloud, it only works with SonarQube. 
- Depends on an external tool to generate a compatible SonarQube plugin.
- To install or update the plugin you must tinker with the SonarQube server filesystem.
- The SonarQube analysis result might be inconsistent if a roslyn rule doesn't specify a location _(more information in the "Issue when integration a roslyn rule with no location with SonarQube" section)_.

# **Import the issues report generated by your Roslyn Analyzer into SonarQube.**

Another way to integrate a Roslyn Analyzer with SonarQube is to import the issues report generated by you Roslyn Analyzer into SonarQube.   

This is a really simply process with only 2 steps:
- Package your Roslyn Analyzer into a NuGet package
- Install this package in your .NET applications.

Issues generated from your Roslyn Analyzer are included in the MSBuild output and imported by default into SonarQube.

This integration is easier than the other one, but lacks some features (such as being able to control their execution by inclusion in a quality profile).

Let me show you an end-to-end example.

## **Example**

### **Step 1: Install the Roslyn Analyzer NuGet in the target application**

The fist step is to install the Roslyn Analyzer NuGet package into the target application. 

I have built and packed a Roslyn Analyzer library in advance. The library contains a simple (and stupid) rule that reports a diagnostic if a class name contains a lowercase letters.
- You can find the Roslyn Analyzer library source code on my [Github repository](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube/tree/main/MyRoslynAnalyzer).
- You can get the NuGet package from [nuget.org](https://www.nuget.org/packages/MyRoslynAnalyzer).

Using Visual Studio you can browse the rules installed on your target application. You will see your rules NuGet package listed on the "Dependencies > Analyzers" section when you install it on the target application.

![sonarqube-net7-api-custom-analyzers](/img/sonarqube-net7-api-custom-analyzers.png)

And the next code snippet shows how the ``.csproj`` file looks like:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="7.0.3" />
    <PackageReference Include="MyRoslynAnalyzer" Version="1.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
  </ItemGroup>

</Project>
```

### **Step 2: Run a Sonar scan**

The second and last step is perform a scan on a .NET application to test that the custom rules are imported into sonarQube as expected.

- The app source code I will use to perform this test can be found  on my [Github repository](https://github.com/karlospn/how-to-integrate-roslyn-analyzers-with-sonarqube/tree/main/Demo.WebApi).
- To perform a SonarQube scan I will use the [SonarScanner CLI](https://github.com/SonarSource/sonar-scanner-cli) tool.

We can perform a ``dotnet build`` command after installing the NuGet containing the rules and we will see the rules result on the build output.

![sonarqube-dotnet-build-output](/img/sonarqube-dotnet-build-output.png)

Now we need to import the build output into SonarQube, to do that we must perform a SonarQube scan using the SonarScanner command tool, the next code snippet shows an example of how to do it.

```bash
dotnet sonarscanner begin /k:"MyDemo.WebApi" /d:sonar.login="sqa_4278ef757202aaa56f0b632344a966be85a9383b" /d:sonar.host.url="http://localhost:9000"

dotnet build

dotnet sonarscanner end /d:sonar.login="sqa_4278ef757202aaa56f0b632344a966be85a9383b"
```

One parameter needed when creating a roslyn rule is the ``DiagnosticSeverity``. In the next example we're creating a rule with a ``DiagnosticSeverity.Warning``, which means that if this rule reports a diagnostic it will use a error level of warning.

```csharp
private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, 
    Title, 
    MessageFormat, 
    Category, 
    DiagnosticSeverity.Warning, 
    isEnabledByDefault: true, 
    description: Description,
    helpLinkUri: HelpLink);
```
If we use the ``DiagnosticSeverity.Error`` when creating a rule on our Roslyn Analyzer when this rule reports a diagnostic it will use an error level of Error, which means that it will break the ``dotnet build`` command and we won't be able to import this issue into SonarQube. 
To solve this problem we have 2 options:
- Set the ``DiagnosticSeverity`` attribute as ``Warning`` on our rules.
- Use an ``.editorconfig`` file to set the error level.


If we inspect the resulting analysis on SonarQube, we'll see that the rules from the NuGet where imported successfully into SonarQube.

![sonarqube-external-issues-error](/img/sonarqube-external-issues-error.png)

One of the biggest disadvantages when using the plugin approach to integrate our roslyn analyzers with SonarQube is the fact that it doesn't work with SonarCloud.    
This approach can be used with sonarcloud without any problem, the next screenshot shows how the  rules from the NuGet where imported successfully into SonarCloud.

![sonarqube-external-issues-error-on-sonarcloud](/img/sonarqube-external-issues-error-on-sonarcloud.png)

## **Pros and cons**

**Pros**
- Very easy to implement.
- Works with both SonarQube and SonarCloud.

**Cons**
- Unable to configure the rules in SonarQube. The issues are always reported as external issues.
- You have to install the roslyn analyzer rules library as a NuGet package on the target application. This model of integrating with SonarQube relies in the fact that the application developer must install the rules package on the application.
- Unable to report issues when a roslyn rule doesn't specify a location _(more information in the "Issue when integration a roslyn rule with no location with SonarQube" section)_.

# **Issue when integration a roslyn rule with no location with SonarQube**

> _If someone knows a way to fix this issue, DM me on Github or Linkedin._

Take a look at this rule:

```csharp
public class ClassContainsLowerCaseCharactersAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "MTR-001";

    private static readonly LocalizableString Title = new LocalizableResourceString(nameof(Resources.AnalyzerTitle), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormat), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString Description = new LocalizableResourceString(nameof(Resources.AnalyzerDescription), Resources.ResourceManager, typeof(Resources));
    private const string Category = "Naming";
    private const string HelpLink = "https://www.mytechramblings.com";

    private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, 
        Title, 
        MessageFormat, 
        Category, 
        DiagnosticSeverity.Warning, 
        isEnabledByDefault: true, 
        description: Description,
        helpLinkUri: HelpLink);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();
        context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
    }

    private static void AnalyzeSymbol(SymbolAnalysisContext context)
    {
        var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

        if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
        {
            var diagnostic = Diagnostic.Create(Rule, Location.None);
            context.ReportDiagnostic(diagnostic);
        }
    }
}
```

It is a (stupid) rule that reports a diagnostic for every class name that contains a lowercase. If we test this rule on a newly created .NET 7 api, here's the build output:

![sonarqube-csc-location-none](/img/sonarqube-csc-location-none.png)

As you can observe from the previous screenshot, the csharp compiler has raised 3 warnings, but those warnings had no concrete location, this is because the rule doesn't specify the location when reporting a diagnostic.

```csharp
var diagnostic = Diagnostic.Create(Rule, Location.None);
context.ReportDiagnostic(diagnostic);
```

If we integrate this rule using the plugin approach, this is what we will see on SonarQube:

![sonarqube-plugin-location-none-wrong-findings.png](/img/sonarqube-plugin-location-none-wrong-findings.png)

As you can see, there is only 1 issue present when the csharp compile report 3 warnings.

It is even worse when we integrate this rule with SonarQube using the issues report generated by the ``sonarscanner`` tool, becase no issue appears on SonarQube.

![sonarqube-location-none-no-findings](/img/sonarqube-location-none-no-findings.png)

In conclusion, if you have a rule that doesn't report a location, it might not show up in SonarQube.
